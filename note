生成一个临时变量，把它的引用作为函数参数传入函数内

map底层是基于红黑树实现的，因此map内部元素排列是有序的。而unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。

容器 迭代器 函数对象 算法 适配器 

1）vector底层实现是数组；list是双向 链表。
2）vector支持随机访问，list不支持。
3）vector是顺序内存，list不是。
4）vector在中间节点进行插入删除会导致内存拷贝，list不会。
5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。
6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。

vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。
list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。

迭代器封装了指针，是一个“可遍历STL容器内全部或部分元素”的对象，
本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。
Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

resize()：改变当前容器内含有元素的数量(size())
reserve()：改变当前容器的最大容量（capacity）,它不会生成元素

预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件

对于使用双引号包含的头文件，查找头文件路径的顺序为：当前头文件目录……

段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：使用野指针 试图修改字符串常量的内容

1、临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；
2、互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
3、信号量 Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
4、事件(信号)，Wait/Notify：

nullptr空指针

开放定址法: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。
再哈希法：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。
链地址法：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中
建立公共溢出区：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。

哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。
C++的hash表中有一个负载因子loadFactor,当Hash表中loadFactor==1时进行rehash。
模仿C++的vector扩容方式就开辟一个原来桶数组的两倍空间然后把原来的桶数组中元素全部重新哈希到新的桶数组中。

hash表的实现主要包括构造哈希和处理哈希冲突

快速排序、堆排序O(nlogn) 不稳定
归并排序O(nlogn) 计数排序O(n+k)，k是待排序数的范围 稳定
桶排序O(n+C) ，C为桶内排序时间

基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序稳定

堆是由低地址向高地址扩展；栈是由高地址向低地址扩展
堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存
堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片
堆的分配效率较低，而栈的分配效率较高

栈的效率高的原因：
栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。

AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。
所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。

事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。

函数的声明extern关键词是可有可无的，因为函数本身不加修饰的话就是extern。但是引用的时候一样需要声明的。
extern int i;  //声明i而非定义
extern int v = 2; //定义
extern一般是使用在多文件之间需要共享某些代码时。
默认情况下，一个const对象仅在本文件内有效，如果多个文件中出现了同名的const变量时，其实等同于在不同的文件中分别定义了独立的变量。
对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了，在多个文件中共享const对象
extern "C"  告诉编译器在编译这个函数名时按着C的规则去翻译相应的函数名而不是C++的

1 static修饰局部变量
static修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序退出时销毁。
2 static修饰全局变量
全局变量本来就存储在静态区，因此static并不能改变其存储位置。但是，static限制了其链接属性。被static修饰的全局变量只能被该包含该定义的文件访问。
3 static修饰函数
static修饰函数使得函数只能在包含该函数定义的文件中被调用，不能在其他源文件中被引用，对于静态函数，声明和定义需要放在同一个文件中。
在多人协同工作的项目中，为了避免出现同名的函数冲突，可以将函数定义为static，从而避免冲突的发生。
4 静态成员变量和静态成员函数。所有的对象都只维持同一个实例。采用static可以实现不同对象之间数据共享。

Volatile
第一个特性：易变性。在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。
第二个特性：”不可优化”性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。
Volatile关键词的两个特性，让它经常被解读为一个为多线程而生的关键词：
一个全局变量，会被多线程同时访问/修改，那么线程内部，就不能假设此变量的不变性，并且基于此假设，来做一些程序设计。
这样的假设，本身并没有什么问题，多线程编程，并发访问/修改的全局变量，通常都会建议加上Volatile关键词修饰，来防止C/C++编译器进行不必要的优化。
但是，很多时候，C/C++ Volatile关键词，在多线程环境下，会被赋予更多的功能，从而导致问题的出现。
第三个特性：顺序性。 Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。
两个Volatile变量间的操作，是不会被编译器交换顺序的。但是CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力。

new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化；
new是一个操作符可以重载，malloc是一个库函数；
